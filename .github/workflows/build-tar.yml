name: Build frontend & backend Docker images (amd64) and export docker-tars

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image version tag, e.g. v1.2.3"
        type: string
        required: true
        default: "v1.0.0"
      prod_build:
        description: "Use production Dockerfiles (true) or dev (false)"
        type: boolean
        required: false
        default: true

permissions:
  contents: read

  concurrency:
    group: build-tar-${{ github.ref }}-${{ toLower(inputs.image_tag) }}
    cancel-in-progress: true

defaults:
  run:
    shell: bash

jobs:
  build-export:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        include:
          - service: backend
            context: backend
            dockerfile_prod: backend/Dockerfile.prod
            dockerfile_dev: backend/Dockerfile
            image_name: myapp-backend
          - service: frontend
            context: frontend
            dockerfile_prod: frontend/Dockerfile.prod
            dockerfile_dev: frontend/Dockerfile
            image_name: myapp-frontend
          - service: postgres
            context: postgres
            dockerfile_prod: postgres/Dockerfile
            dockerfile_dev: postgres/Dockerfile
            image_name: myapp-postgres
    env:
      PLATFORM: linux/amd64
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set DATABASE_URL for backend
        run: echo "DATABASE_URL=postgres://csuser:change_me@postgres:5432/cslibrary" >> $GITHUB_ENV

      - name: Set variables
        run: |
          OWNER_LC="$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')"
          IMAGE_TAG="$(echo "${{ inputs.image_tag }}" | tr '[:upper:]' '[:lower:]')"
          echo "OWNER_LC=$OWNER_LC" >> $GITHUB_ENV
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          if [ "${{ inputs.prod_build }}" = "true" ]; then
            if [ "${{ matrix.service }}" = "frontend" ]; then
              echo "[warn] frontend prod build requested but production Dockerfile lacks devDependencies -> fallback to dev" >&2
              DF="${{ matrix.dockerfile_dev }}"
            else
              DF="${{ matrix.dockerfile_prod }}"
            fi
          else
            DF="${{ matrix.dockerfile_dev }}"
          fi
          echo "DOCKERFILE=$DF" >> $GITHUB_ENV
          echo "IMAGE_NAME=${{ matrix.image_name }}" >> $GITHUB_ENV
          echo "SERVICE=${{ matrix.service }}" >> $GITHUB_ENV
          SAFE_IMAGE_TAG=$(echo "$IMAGE_TAG" | tr '/' '-')
          echo "SAFE_IMAGE_TAG=$SAFE_IMAGE_TAG" >> $GITHUB_ENV

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build ${{ matrix.service }} and export docker-tar
        run: |
          OUT_BASENAME="${SERVICE}_${IMAGE_TAG}_amd64"
          docker buildx build "${{ matrix.context }}" \
            -f "$DOCKERFILE" \
            --platform "$PLATFORM" \
            --tag "$IMAGE_NAME:$IMAGE_TAG" \
            --output "type=docker,dest=${OUT_BASENAME}.tar"
          echo "Built image: $IMAGE_NAME:$IMAGE_TAG -> ${OUT_BASENAME}.tar"
          ls -lh "${OUT_BASENAME}.tar"

        - name: Push image to GitHub Container Registry
          run: |
            OUT_BASENAME="${SERVICE}_${IMAGE_TAG}_amd64"
            docker load -i "${OUT_BASENAME}.tar"
            docker tag "$IMAGE_NAME:$IMAGE_TAG" "ghcr.io/$OWNER_LC/$IMAGE_NAME:$IMAGE_TAG"
            docker push "ghcr.io/$OWNER_LC/$IMAGE_NAME:$IMAGE_TAG"

      - name: Compress & checksum
        run: |
          OUT_BASENAME="${SERVICE}_${IMAGE_TAG}_amd64"
          echo "$IMAGE_NAME:$IMAGE_TAG" > "${OUT_BASENAME}.images.txt"
          gzip -9 "${OUT_BASENAME}.tar"
          sha256sum "${OUT_BASENAME}.tar.gz" > "${OUT_BASENAME}.tar.gz.sha256"
          ls -lh "${OUT_BASENAME}.tar.gz"
          cat "${OUT_BASENAME}.tar.gz.sha256"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.SERVICE }}-${{ env.SAFE_IMAGE_TAG }}-amd64
          path: |
            ${{ env.SERVICE }}_${{ env.IMAGE_TAG }}_amd64.tar.gz
            ${{ env.SERVICE }}_${{ env.IMAGE_TAG }}_amd64.tar.gz.sha256
            ${{ env.SERVICE }}_${{ env.IMAGE_TAG }}_amd64.images.txt
          if-no-files-found: error
          retention-days: 7

  summary:
    needs: build-export
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Summary
        run: |
          echo "Services: backend, frontend, postgres" >> $GITHUB_STEP_SUMMARY
          echo "Tag: ${{ toLower(inputs.image_tag) }}" >> $GITHUB_STEP_SUMMARY
          echo "prod_build: ${{ inputs.prod_build }}" >> $GITHUB_STEP_SUMMARY
          echo "Note: frontend may fallback to dev Dockerfile if prod lacks dev deps." >> $GITHUB_STEP_SUMMARY

  deploy:
    needs: build-export
    runs-on: ubuntu-latest
    env:
      OWNER_LC: ${{ toLower(github.repository_owner) }}
      IMAGE_TAG: ${{ toLower(inputs.image_tag) }}
    steps:
      - name: Pull images from GitHub Container Registry
        run: |
          docker pull ghcr.io/$OWNER_LC/myapp-postgres:$IMAGE_TAG
          docker pull ghcr.io/$OWNER_LC/myapp-backend:$IMAGE_TAG
          docker pull ghcr.io/$OWNER_LC/myapp-frontend:$IMAGE_TAG
      - name: Run containers with shared network
        run: |
          docker network create app-net
          docker run -d --name postgres --network app-net -e POSTGRES_DB=cslibrary -e POSTGRES_USER=csuser -e POSTGRES_PASSWORD=change_me ghcr.io/$OWNER_LC/myapp-postgres:$IMAGE_TAG
          docker run -d --name backend --network app-net -e DATABASE_URL=postgres://csuser:change_me@postgres:5432/cslibrary ghcr.io/$OWNER_LC/myapp-backend:$IMAGE_TAG
          docker run -d --name frontend --network app-net -e DATABASE_URL=postgres://csuser:change_me@postgres:5432/cslibrary ghcr.io/$OWNER_LC/myapp-frontend:$IMAGE_TAG
